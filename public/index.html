<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="/favicon.ico" />
  <title>OneShell</title>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&family=Fira+Mono&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css" />
  <script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.7.0/lib/xterm-addon-fit.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');

    * {
      box-sizing: border-box;
      font-family: 'Inter', 'Segoe UI', sans-serif;
    }

    body {
      margin: 0;
      display: flex;
      height: 100vh;
      background-color: #f9fafb;
    }

    .sidebar {
      width: 320px;
      padding: 24px;
      background-color: #ffffff;
      border-right: 1px solid #e2e8f0;
      display: flex;
      flex-direction: column;
      gap: 18px;
      font-size: 16px;
      font-weight: 400;
      box-shadow: 2px 0 4px rgba(0, 0, 0, 0.04);
    }

    .sidebar h2 {
      margin: 0 0 20px;
      font-weight: 600;
      font-size: 22px;
      color: #1a202c;
    }

    .sidebar input,
    .sidebar button {
      width: 100%;
      padding: 12px 14px;
      margin-top: 6px;
      border: 1.5px solid #cbd5e0;
      border-radius: 8px;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .sidebar input:focus {
      border-color: #6c5ce7;
      box-shadow: 0 0 6px rgba(108, 92, 231, 0.3);
      outline: none;
    }

    .sidebar button {
      background-color: #6c5ce7;
      color: white;
      font-weight: 600;
      border: none;
      cursor: pointer;
      margin-top: 12px;
      transition: background-color 0.3s ease;
    }

    .sidebar button:hover {
      background-color: #5a4dcf;
    }

    .button-row {
      display: flex;
      gap: 12px;
      margin-top: -16px;
    }

    .button-row button {
      flex: 1;
      padding: 12px 14px;
      border: none;
      border-radius: 8px;
      background-color: #6c5ce7;
      color: white;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .button-row button:hover {
      background-color: #5a4dcf;
    }

    .connection-list {
      flex-grow: 1;
      overflow-y: auto;
      padding-top: 12px;
      border-top: 1px solid #e2e8f0;
    }

    .connection-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 14px;
      border-radius: 8px;
      background-color: #f7fafc;
      margin-bottom: 10px;
      cursor: pointer;
      font-weight: 500;
      color: #2d3748;
      transition: background-color 0.2s ease;
    }

    .connection-item:hover {
      background-color: #e0e7ff;
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: red;
      flex-shrink: 0;
    }

    #terminal {
      flex-grow: 1;
      height: 100%;
      background-color: #1e1e1e;
      overflow-x: hidden;
      font-family: 'JetBrains Mono', 'Fira Mono', monospace !important;
    }

    .xterm-viewport,
    .xterm-screen {
      padding-left: 10px !important;
      overflow-x: hidden !important;
    }

    .info {
      font-size: 13px;
      color: #718096;
      margin-top: 8px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <img src="logo.png" alt="OneShell Logo" style="height: auto; margin-bottom: 16px;" />
    <input type="text" id="name" placeholder="Connection Name" />
    <input type="text" id="ip" placeholder="IP Address" />
    <input type="text" id="user" placeholder="Username" />
    <input type="password" id="password" placeholder="Password" />
    <button onclick="addConnection()">Save & Start Connection</button>
    <div class="button-row">
      <button onclick="downloadConnections()">â¬‡ Download</button>
      <button onclick="document.getElementById('fileInput').click()">â¬† Upload</button>
      <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="uploadConnections(event)" />
    </div>
    <div class="connection-list" id="connections"></div>
    <div class="info">ðŸ’¡ Drag to reorder. Right-click to delete.</div>
  </div>
  <div id="terminal"></div>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const term = new Terminal({
      fontSize: 14,
      fontFamily: 'Fira Mono, monospace',
      lineHeight: 1.3,
      letterSpacing: -0.5,
      convertEol: false,
      cursorStyle: 'bar',
      cursorBlink: true,
      theme: {
        background: '#1e1e1e',
        foreground: '#ffffff',
        cursor: '#6c5ce7'
      }
    });
    const fitAddon = new FitAddon.FitAddon();
    term.loadAddon(fitAddon);
    term.open(document.getElementById('terminal'));
    setTimeout(() => fitAddon.fit(), 0);
    window.addEventListener('resize', () => fitAddon.fit());

    term.attachCustomKeyEventHandler(e => {
      if (e.ctrlKey && !e.shiftKey && e.code === 'KeyC') {
        if (term.hasSelection()) {
          navigator.clipboard.writeText(term.getSelection());
          e.preventDefault(); return false;
        }
      }
      if (e.ctrlKey && !e.shiftKey && e.code === 'KeyV') {
        navigator.clipboard.readText().then(text => term.paste(text));
        e.preventDefault(); return false;
      }
      return true;
    });

    let inputBuffer = '', sendTimeout;
    term.onData(data => {
      inputBuffer += data;
      if (!sendTimeout) {
        sendTimeout = setTimeout(() => {
          socket.emit('input', inputBuffer);
          inputBuffer = ''; sendTimeout = null;
        }, 50);
      }
    });

    const keyString = 'mysecretkey12345';
    let cryptoKey;
    async function getCryptoKey() {
      if (cryptoKey) return cryptoKey;
      const keyData = new TextEncoder().encode(keyString);
      cryptoKey = await crypto.subtle.importKey('raw', keyData, 'AES-GCM', false, ['encrypt', 'decrypt']);
      return cryptoKey;
    }
    async function encrypt(text) {
      const key = await getCryptoKey();
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encoded = new TextEncoder().encode(text);
      const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, encoded);
      const combined = new Uint8Array(iv.length + cipher.byteLength);
      combined.set(iv, 0);
      combined.set(new Uint8Array(cipher), iv.length);
      return btoa(String.fromCharCode(...combined));
    }
    async function decrypt(data) {
      const key = await getCryptoKey();
      const combined = Uint8Array.from(atob(data), c => c.charCodeAt(0));
      const iv = combined.slice(0, 12);
      const cipher = combined.slice(12);
      const plainBuffer = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, cipher);
      return new TextDecoder().decode(plainBuffer);
    }

    let connections = [];
    const connectionsEl = document.getElementById('connections');

    socket.emit('get-connections');
    socket.on('connections-data', data => {
      connections = data;
      renderConnections();
    });

    async function renderConnections() {
      connectionsEl.innerHTML = '';
      for (let conn of connections) {
        const div = document.createElement('div');
        div.className = 'connection-item';
        const dot = document.createElement('div');
        dot.className = 'dot';
        dot.style.backgroundColor = 'red';
        const nameText = document.createElement('span');
        nameText.textContent = conn.name;
        div.appendChild(dot);
        div.appendChild(nameText);
        div.onclick = async () => {
          const pwd = await decrypt(conn.password);
          startSSHConnection({ ip: conn.ip, user: conn.user, password: pwd, name: conn.name });
        };
        div.oncontextmenu = e => {
          e.preventDefault();
          if (confirm(`Delete connection ${conn.name}?`)) {
            socket.emit('delete-connection', conn.name);
          }
        };
        div.dataset.name = conn.name;
        connectionsEl.appendChild(div);
        pingHost(conn.ip, dot);
      }
    }

    function pingHost(ip, dotElement) {
      socket.emit('ping-host', ip);
      const onPingResult = (result) => {
        if (result.host === ip) {
          dotElement.style.backgroundColor = result.alive ? 'green' : 'red';
          socket.off('ping-result', onPingResult);
        }
      };
      socket.on('ping-result', onPingResult);
    }

    function refreshStatuses() {
      for (let i = 0; i < connections.length; i++) {
        const dot = connectionsEl.children[i].querySelector('.dot');
        pingHost(connections[i].ip, dot);
      }
    }

    setInterval(refreshStatuses, 5000);

    function addConnection() {
      const name = document.getElementById('name').value.trim();
      const ip = document.getElementById('ip').value.trim();
      const user = document.getElementById('user').value.trim();
      const password = document.getElementById('password').value;
      if (!name || !ip || !user || !password) return alert('Please fill in all fields.');
      encrypt(password).then(encPwd => {
        const connection = { name, ip, user, password: encPwd };
        socket.emit('save-connection', connection);
        document.getElementById('name').value = '';
        document.getElementById('ip').value = '';
        document.getElementById('user').value = '';
        document.getElementById('password').value = '';
      });
    }

    function startSSHConnection({ ip, user, password, name }) {
      socket.emit('start-ssh', { ip, user, password });
      term.reset();
      term.writeln(`Connected to ${name} (${ip})`);
    }

    socket.on('output', data => term.write(data));
    socket.on('ssh-error', err => term.writeln(`\r\nERROR: ${err}\r\n`));

    new Sortable(connectionsEl, {
      animation: 150,
      onEnd: () => {
        const reordered = [];
        Array.from(connectionsEl.children).forEach(child => {
          const name = child.dataset.name;
          const item = connections.find(c => c.name === name);
          if (item) reordered.push(item);
        });
        connections = reordered;
        socket.emit('update-connections-order', reordered);
      }
    });

    function downloadConnections() {
      const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(connections, null, 2));
      const dlAnchor = document.createElement('a');
      dlAnchor.setAttribute("href", dataStr);
      dlAnchor.setAttribute("download", "connections.json");
      dlAnchor.click();
    }

    function uploadConnections(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const imported = JSON.parse(e.target.result);
          if (Array.isArray(imported)) {
            connections = imported;
            socket.emit('update-connections-order', imported);
          } else {
            alert("Invalid file format.");
          }
        } catch (err) {
          alert("Error parsing JSON file.");
        }
      };
      reader.readAsText(file);
    }
  </script>
</body>
</html>