<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="images/favicon.ico" />
  <title>OneShell</title>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css" />
  <link rel="stylesheet" href="stylesheets/style.css" />
  <link rel="stylesheet" href="stylesheets/colors.css" />
  <script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.7.0/lib/xterm-addon-fit.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</head>
<body>
  <div class="sidebar">
    <img src="images/logo.png" alt="OneShell Logo" style="height: auto; margin-bottom: 16px;" />
    <input type="text" id="name" placeholder="Connection Name" />
    <input type="text" id="ip" placeholder="IP Address" />
    <input type="text" id="user" placeholder="Username" />
    <input type="password" id="password" placeholder="Password" />
    <button onclick="addConnection()">Save Connection</button>
    <div class="button-row">
      <button onclick="downloadConnections()">â¬‡ Download</button>
      <button onclick="document.getElementById('fileInput').click()">â¬† Upload</button>
      <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="uploadConnections(event)" />
    </div>
    <div class="connection-list" id="connections"></div>
    <div class="info">ðŸ’¡ Drag to reorder. Right-click to delete.</div>
  </div>
  <div id="terminal" style="font-family: 'JetBrains Mono', monospace;"></div>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let term, fitAddon;

    function initializeTerminal() {
      term = new Terminal({
        fontSize: 14,
        fontFamily: '"JetBrains Mono", monospace',
        lineHeight: 1.3,
        letterSpacing: 0,
        convertEol: true,
        cursorStyle: 'bar',
        cursorBlink: true,
        theme: {
          background: '#1e1e1e',
          foreground: '#ffffff',
          cursor: '#6c5ce7'
        },
        rendererType: 'canvas'
      });

      fitAddon = new FitAddon.FitAddon();
      term.loadAddon(fitAddon);

      const container = document.getElementById('terminal');
      container.innerHTML = '';
      term.open(container);
      fitAddon.fit();
      term.focus();
      setTimeout(() => term.focus(), 100);

      window.addEventListener('resize', () => {
        fitAddon.fit();
        socket.emit('resize', { cols: term.cols, rows: term.rows });
      });

      term.attachCustomKeyEventHandler(e => {
        if (e.ctrlKey && !e.shiftKey && e.code === 'KeyC') {
          if (term.hasSelection()) {
            navigator.clipboard.writeText(term.getSelection());
            e.preventDefault(); return false;
          }
        }
        if (e.ctrlKey && !e.shiftKey && e.code === 'KeyV') {
          navigator.clipboard.readText().then(text => {
            term.paste(text);
          });
          e.preventDefault(); return false;
        }
        return true;
      });

      term.onData(data => {
        socket.emit('input', data);
      });

      socket.off('output');
      socket.on('output', data => {
        term.write(data);
      });

      socket.off('ssh-error');
      socket.on('ssh-error', err => term.writeln(`\r\nERROR: ${err}\r\n`));
    }

    const keyString = 'mysecretkey12345';
    let cryptoKey;

    async function getCryptoKey() {
      if (cryptoKey) return cryptoKey;
      const keyData = new TextEncoder().encode(keyString);
      cryptoKey = await crypto.subtle.importKey('raw', keyData, 'AES-GCM', false, ['encrypt', 'decrypt']);
      return cryptoKey;
    }

    async function encrypt(text) {
      const key = await getCryptoKey();
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encoded = new TextEncoder().encode(text);
      const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, encoded);
      const combined = new Uint8Array(iv.length + cipher.byteLength);
      combined.set(iv, 0);
      combined.set(new Uint8Array(cipher), iv.length);
      return btoa(String.fromCharCode(...combined));
    }

    async function decrypt(data) {
      const key = await getCryptoKey();
      const combined = Uint8Array.from(atob(data), c => c.charCodeAt(0));
      const iv = combined.slice(0, 12);
      const cipher = combined.slice(12);
      const plainBuffer = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, cipher);
      return new TextDecoder().decode(plainBuffer);
    }

    let connections = [];
    const connectionsEl = document.getElementById('connections');

    socket.emit('get-connections');
    socket.on('connections-data', data => {
      connections = data;
      renderConnections();
    });

    async function renderConnections() {
      connectionsEl.innerHTML = '';
      for (let conn of connections) {
        const div = document.createElement('div');
        div.className = 'connection-item';
        const dot = document.createElement('div');
        dot.className = 'dot';
        dot.style.backgroundColor = 'red';
        const nameText = document.createElement('span');
        nameText.textContent = conn.name;
        div.appendChild(dot);
        div.appendChild(nameText);
        div.onclick = async () => {
          const pwd = await decrypt(conn.password);
          startSSHConnection({ ip: conn.ip, user: conn.user, password: pwd, name: conn.name });
        };
        div.oncontextmenu = e => {
          e.preventDefault();
          if (confirm(`Delete connection ${conn.name}?`)) {
            socket.emit('delete-connection', conn.name);
          }
        };
        div.dataset.name = conn.name;
        connectionsEl.appendChild(div);
        pingHost(conn.ip, dot);
      }
    }

    function pingHost(ip, dotElement) {
      socket.emit('ping-host', ip);
      const onPingResult = (result) => {
        if (result.host === ip) {
          dotElement.style.backgroundColor = result.alive ? 'green' : 'red';
          socket.off('ping-result', onPingResult);
        }
      };
      socket.on('ping-result', onPingResult);
    }

    function refreshStatuses() {
      for (let i = 0; i < connections.length; i++) {
        const dot = connectionsEl.children[i].querySelector('.dot');
        pingHost(connections[i].ip, dot);
      }
    }

    setInterval(refreshStatuses, 5000);

    function addConnection() {
      const name = document.getElementById('name').value.trim();
      const ip = document.getElementById('ip').value.trim();
      const user = document.getElementById('user').value.trim();
      const password = document.getElementById('password').value;
      if (!name || !ip || !user || !password) return alert('Please fill in all fields.');
      encrypt(password).then(encPwd => {
        const connection = { name, ip, user, password: encPwd };
        socket.emit('save-connection', connection);
        document.getElementById('name').value = '';
        document.getElementById('ip').value = '';
        document.getElementById('user').value = '';
        document.getElementById('password').value = '';
      });
    }

    function startSSHConnection({ ip, user, password, name }) {
      if (term) {
        term.dispose();
        document.getElementById('terminal').innerHTML = '';
      }
      initializeTerminal();
      socket.emit('start-ssh', {
        ip, user, password,
        cols: term.cols,
        rows: term.rows
      });
      setTimeout(() => {
        term.writeln(`Connected to ${name} (${ip})`);
        term.focus();
      }, 100);
    }

    function downloadConnections() {
      const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(connections, null, 2));
      const dlAnchor = document.createElement('a');
      dlAnchor.setAttribute("href", dataStr);
      dlAnchor.setAttribute("download", "connections.json");
      dlAnchor.click();
    }

    function uploadConnections(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const imported = JSON.parse(e.target.result);
          if (Array.isArray(imported)) {
            connections = imported;
            socket.emit('update-connections-order', imported);
          } else {
            alert("Invalid file format.");
          }
        } catch (err) {
          alert("Error parsing JSON file.");
        }
      };
      reader.readAsText(file);
    }

    new Sortable(connectionsEl, {
      animation: 150,
      onEnd: () => {
        const reordered = [];
        Array.from(connectionsEl.children).forEach(child => {
          const name = child.dataset.name;
          const item = connections.find(c => c.name === name);
          if (item) reordered.push(item);
        });
        connections = reordered;
        socket.emit('update-connections-order', reordered);
      }
    });

    initializeTerminal();
  </script>
</body>
</html>
